## node.js就是使用js编写后端程序
* node.js把JS只能操控浏览器的语言改变成能够直接和服务端进行交流的语言，让前端被重视起来
* node.js是一个能在服务器端使用Js的开放源代码、跨平台的javascript运行环境
* node采用Google开发的V8引擎运行JS代码，使用事件驱动、非阻塞和异步I/O模型等技术来提高性能，可优化应用程序的传输量和规模
* I/O模型指的是通过服务器向数据库进行写入input和读取output
#### node.js的优势
```
web端是通过客户端的请求 -- 然后到服务器 ---服务器再通过I/O读写数据库 ---然后服务器拿到数据库里的数据再响应给客户端
这个过程中，当时的主流语言java等都是一个请求进来，就新建一个线程，但是如果这个线程还在读写数据库就不能断
那其他的线程就得一起等着，这就是阻塞I/O
这个过程影响速度最多的就是I/O读写数据库这个阶段，所以node.js搭配v8引擎横空出世
node.js处理办法就是，所有的请求都只创建一个线程，这就避免了I/O阻塞，加快了读取速度
```
#### node.js的用途
* node.js可以说是成也单线程，败也单线程，node.js只适合处理访问量不大的网站，不然单线程兜不住
* 大型的网站还是需要Java这种多线程语言来支持
* 但是这个问题可以用分布式来解决，就是多开几个服务器，因为Node对服务器的要求并不高，一台1000块钱的服务器能达到1万块钱的效果
```
Web服务的API 就是类似接口
实时的多人游戏
多客户端的即时通讯
```
#### windows电脑的CMD窗口指令
```
--常用指令
1.dir  						列出当前目录下的所有文件
2.cd   						目录名 进入指定目录
	//如果想去到别的盘可以使用e:或者f:
3.md   						在当前目录下创建一个文件夹
4.rd + 文件夹名字   			删除当前文件夹
5.文件名称(hello.txt)   		打开当前文件
--目录列表
1.  ./当前目录
2.  ../上一级目录  可以这样用cd ../  回到上一页
```
* 当使用命令行打开文件的时候，必须要进入当前目录才能打开，但是有时候有些文件经常被使用，就不可能每次都打开那个文件所在的目录
* 这样会很繁琐，所以引入了一个环境变量，这个环境变量可以理解成是windows系统里面的变量
* 在我的电脑右键属性栏高级系统设置-高级里面有环境变量的选择
* 环境变量也分两种：1.用户变量 2.系统变量
* 1.用户变量是当前用户才能使用(这是常用的，因为使用系统变量有时候可能会出错) 2.系统变量则是所有用户都能使用
```
环境变量就是windows系统里面的变量
环境变量里面有个很重要的Path变量，负责将常用文件的路径进行保存，可以用命令行直接访问到
在新增的时候注意要用分号进行隔开才能新增
只要是在Path里面的路径目录下的所有文件，都能用命令行直接打开，不管命令行当前是处在哪一个目录下都可以
原理:
	当你在命令行使用某个文件的时候，windows默认先从本目录下进行查找，当找不到那个文件之后，会依次在Path的路径下进行寻找
```
#### 进程和线程
* 进程可以在每台电脑的任务管理器中进行查看
* 进程是负责为程序的运行提供必备的环境，就相当于一个工厂
* 在任务管理器中看到的所有进程，都不一定是在运行程序，只有那些占用了CPU的才是有程序在运行
* 而线程则表示在工厂里干活的工人，是真正要使用的程序，在进程提供的特定环境下进行使用，是占用CPU的
* 单线程和多线程，首先多线程不一定效率会比单线程高，但是一般会比单线程高而已，其中js就是单线程的语言，Java是多线程的
```
1.进程
	进程相当于一个工厂，为线程提供程序使用的环境
2.线程
	线程代表计算机的最小计量单位，线程是负责进程中的程序，相当于工厂里的工人
```
#### node语法
* node的执行类似java,在命令行进入当前目录，然后使用node 文件名即可执行文件
###### node模块化
* 在node里面，每个Js文件的JS代码都是独立于文件之中的，换句话说就是每个Js文件虽然是全局作用域，但是也相当于是一个大的自运行的方法
* 在这个方法里面使用变量需要暴露出去才能被别的模块使用到
* ES5模块化引入
```
require("./nodefirst") //即可引入同目录下的文件 ,但是单单这样是无法访问当文件中的变量的，只能启动该文件中的自启动的代码
```
* 如果想要一个文件中的一个变量抛出，另一个模块接收可以使用exports和require
* require进来的模块本质上就是一个对象，里面包含的就是引入文件中导出的部分
```
//抛出的模块one.js
exports.x = "这是啥"

//接收的模块two.js
let md = require("./one")
console.log("打印出来看看",md)
```
* node的模块分两种，和JS一样
* 1.核心模块，直接使用require引入模块名即可，也叫引入模块标识
* 2.文件模块，由用户自己创建的模块，向上面这种引入方式引入，需要加上路径
```
let fs = require("fs") //引入核心模块，直接填写模块名即可
let math = require("./math") //引入具体的文件模块，需要加上文件路径
```
###### node在全局上声明的是局部变量
* 在Node里面有一个类似window的全局变量叫做global，因为Node是后台语言所以没有window
* 但是如果在全局里var 声明一个变量，该变量是一个局部变量，没办法使用global访问到，除非直接声明a = 1
```
var a = 1
b = 1
console.log("global",global.a)   // undefined   如果使用声明就会变成局部变量
console.log("global2",global.b)  // 1      不使用声明就会暴露在全局变量
```
* 这是因为在node执行模块中的代码时，它首先会在最外层套一层如下函数，所以就算你在全局里声明一个变量，那个变量也是局部变量
* 所以实际上node在指向的时候是将代码放在一个方法里面执行，并且在执行方法之前向里面传入了5个实参
* 怎么验证你在全局变量里其实是在一个方法里面呢，可以使用arguments.callee 这个方法是指向一个方法中的自己
```
console.log(arguments.callee)
//为了看清这个方法的真实情况 可以把这个方法变成字符串打印出来
console.log(arguments.callee + "")  //这个时候就显示出最外面那层方法的样子了

function (exports ,require,module,__filename,dirname) {
	...具体代码
}
```
* 其中，模块方法传入的这五个实参的用法如下
```
exports  		-- 用于将模块中的变量或者方法暴露出去
require  		-- 用于引入外部模块
module   		-- 代表当前模块本身，就是方法的本身，其中exports就是module的属性
				-- 换句话说就是既可以使用exports导出，也可以使用module.exports导出
				-- 但是不能将module理解成js的window，还是获取不到当前方法里的变量的
__filename 		-- 当前模块或者说是文件的完整路径 "c:\user\....."
__dirname		-- 当前模块的文件夹完整路径 就是__filename这个文件的文件夹路径，上一级路径
```
* 其中module.exports和exports还是有相当的区别的
* 可以看做exports 是指向 module.exports 并不是exports本身有抛出的能力 所以当要抛出多个的时候优先选择module.exports
```
exports.xxx = "xxx" //只能单个单个的修改
export = {
	name:"asd"  //这样是会报错的，因为exports本身是无法抛出的，只是这个值是指向module.exports所以能够单个更改，但是多个更改就与
}				//module.exports无关了
//综上所述，如果需要抛出变量，优先直接选用module.exports
module.exports = {
	name:"孙悟空",
	age:12,
	getName:function(){ 
		console.log("孙悟空")
	}
}
//上面module.exports是可行的，所以优选module.exports
```
###### 包管理和包结构
* 包实际上就是一个解压之后的文件目录，目录之下应该包含如下文件
```
package.json   		---描述文件  (这个很重要，是用来描述这个包是干嘛的，也是必须要的)
//以下文件可有可无，
bin   				---可执行的二进制文件
lib 				---js代码
doc					---文档
test				---单元测试
```
* 其中package.json里面的需要使用的key值
```
"dependencies":{}  //这一栏是需要的依赖，类似前端的Npm依赖
"description":""  //这一栏是描述，描述该包的作用
"devDependencies":{}  //这一栏是开发依赖，在正式上线的时候是不需要的
"homepage":     //这个是主页的地址
"main":"./xxx"   //这个是主文件，也是入口文件
"maintainers" :    //表示这个包的贡献者，是可以多人的
"name":     //这个是包的名字，当下载下来之后直接用require引入就是这个名字

```
#### 小技巧
* 如果想在某个文件夹下打开cmd，直接在文件夹的路径行输入cmd即可，路径就是当前文件夹下的路径